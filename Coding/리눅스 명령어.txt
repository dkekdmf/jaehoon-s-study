passwd 사용자이름 사용자에 해당하는 비밀번호를 바꿔 주는것
비밀번호를 입력해도 화면상에도 안보임. 하지만 정상적으로 쳐지는것이다.
reboot 재시작 
init 6도 재시작
ifconfig 리눅스 ipconfig 
이게 삐소리가나요

제컴퓨터가 게임할때도 인터넷이 연결됬다안됬다해요
디렉토리는 폴더 
최상위 폴더 : / 
ls는 ls하고 다음에 있는 모든 하위 폴더및 파일을 보여준다.
ls /
명령어 다음에는 명령어의 옵션을 붙일 수 있는데 ls -l / 의 의미는 ls 를 사용할건데 -l옵션을 통해 더 자세히 볼것이고 볼 위치는 /하위폴더를 보겠다. 모든 게아니라 한칸밑에만 
/ : (최상위) 리눅스 시스템안의 모든 파일과 디렉토리의 최상위에 위치하는 디렉토리 (용량이 가장커야함)

/boot : 부팅관련 프로그램저장소 (grub)

/bin : 기본적인 명령어 파일 저장소 (윈도우는 c드라이브 시스템32에 명령어 파일이있음)

/root : 관리자 홈 디렉토리 (root의 홈 디렉토리) 

* 홈 디렉토리란 계정의 접속위치, 계정의 전용공간,root계정은 히스(개인)계정에 접속가능 반대는 불가

/home : 계정표시는 /home/계정이름 사용자의 홈 디렉토리가 생성되는 공간

/dev : 장치파일의 저장소 (device의 줄임말)
        USB사용방식 : window -> Plig&Play (자동장치연결) Linux -> mount (수동장치연결)

/lib : 언어관련 파일 저장소

/mnt , /media : cd롬이나 floppy 디스켓 등 이동식 저장장치가 연결되는 장소

/sbin  : 시스템관리 명령어 저장소

/usr : 응용프로그램이 저장되는 저장소 (window의 Program Files)

/proc : 프로세스정보가 들어있는 가상 파일 저장소

/var : 메일, 시스템로그, 에러로그(기록)

swap : 가상 메모리, 메모리가 초과시 임시처리 (일반적으로 용량을 메모리의 두배로줌) 디렉토리아님
파일시스템의 종류

/tmp : 임시 저장소 (윈도우의 temp)

/etc : 시스템 설정 파일 저장소 (전반적인 시스템을 관리할려면 여기로)






명령어의 법칙

1. 명령어 [옵션] [target] 순서

2. 명령어의 옵션은 조합이 가능하다

3. 작업 디렉토리내의 작업은 현재 경로 까지 생략 가능하다.

4. 띄어쓰기시에 새로운 경로 및 옵션이 적용된다.

5. 여러 경로 존재 시, 가장 마지막 경로가 타겟이 된다

6. 모순되는 옵션 존재시 가장 마지막 옵션이 적용된다
-c 생성 -d삭제 이렇게서로 모순되는 명령이있으면 ex) -cd 타겟 이면 d옵션만 적용됨 
pwd : 현재 자신이 어디 위치에 있는지 가르쳐준다.
~ : 현재접속한 유저의 홈디렉토리를 나타낸다.
cd : cd target으로자신의 위치를 옮긴다.

명령어를 쓸 때 target을 설정안하고 명령어를 실행한다면 현재 자기 위치가 target이 된다.

절대 경로 : cd /root/xx/a

상대 경로 : /root/xx cd여 

clear : 화면이 복잡할때 화면 깨끗이.



ls옵션

-a 모든파일과 디렉토리표시 (숨김파일)

-l 자세히 출력 (자주쓰임)

-R 하위경로와 그안에 있는 모든 파일까지 표시

ls /etc하면 etc디렉토리를 보여줌 

ls -l /etc 를 하면 자세히 보여줌

ls -l /home/heath 현재위치에따라 상대경로와 절대경로로 써주자

-al 하면 모든파일과 디렉토리를 자세히 표시 (숨김파일도 볼수있음)

그냥 ls -l을하면 현재 pwd의 디렉토리와 파일을 보여줌

두개를 동시에 나타내고 싶으면 ls -l [디렉토리명] [디렉토리명] 리눅스는 띄어쓰기를 구분함 

ls -lR 디렉토리명 을하면 현재디렉토리 하위의 디렉토리와 파일 모두 최하위까지 출력한다
R은 보안상위험하므로 (다보여줘서) 막아놓은서버도있음

man 명령어 : 그 명령어의 모든 옵션을 보여준다.

- : 일반파일

d : 디렉토리

l : 링크파일

mkdir 폴더이름 : 현재 자기자신의 위치에 하위 폴더에 폴더새성
/ 절대경로 : 절대경로에 폴더를 만든다.

touch target : 파일 생성

touch [옵션] [타겟(만든이름)]

touch -d 시간:분 [target] : 당일의 해당 시간,분으로 변경

touch -d 12:34 1 를 하면 파일 1의 시간을 12:34로 변경

-rw-r--r--. 1 root root 0 2018-09-12 12:34 1 이런식으로 바뀜

touch -t [yyyy]mmddhhmm[.ss] [target] 해당 년월일시분초로 변경 (띄어쓰기 필요없음)

*[]로 표시한 년도와초는 생략이 가능하다

ex) touch -t 201809120834 2

touch -t 11112222 2
이런식으로 연도 생략시에는 시스템의 년도를 불러옴 (현재년도)

mkdir 6으로 6생성후에

touch -d 11:11 6 을해도 바꿔진다

touch -t 199901011111 6 로해도댐

cp [옵션] [원본] [위치]
-i : 대상 파일이 이미 존재하는 경우 덮어쓸것인지 물어본다

-r : 디렉토리,파일복사 그냥 항상 붙이자 디렉토리 복사시에는 디렉토리 하위 인스턴스도 가져온다

-p : 원본 파일의 권한,소유자,시간정보를 보존하며 복사한다

d : 디렉토리

l : 링크파일

cp [옵션] [원본] [위치] 카피 복사 
clear 화면을 지우는게 아니라 위로 올려주는것

mv 무브 명령어 이동하는것, 파일의 이름을 변경시키는것, 잘라내기와 같다.
mv (move)

파일이나 디렉토리 이동, 이름 변경 용도로도 사용가능
옵션이 필요없다

/mvfile 디렉토리 생성후 a,b,c 디렉토리 생성, 1 2 3 파일 생성
/mvtest 디렉토리 생성

mv /mvfile/1 /mvtest/1    mvfile/1을  mvtest/1로 옮겨라 복사가아니라 이동임 mvfile의1은사라짐
mv /mvfile/2 /mvtest   이름안쓰고도 옮겨짐
mv /mvfile/3 moon      현재위치에 moon으로 이름을 바꾸어서 이동시키겠다
mv /mvfile/a .      현재위치로 a라는 디렉토리를 옮기겠다
mv /mvfile/b /mvfile/c .    b와c를 현재위치로

mv moon 3      moon을 3으로 이름바꿈

넵넵이게 슬래쉬를 안해서 그런가여

mv /test1/mvfile1/a /test1/mvtest1/b

rm(remove) 삭제명령어 

사용방법 : -rf는 r은 즉각적으로 f는 강제적으로 매우 위험한  명령어 

/test가 현재위치이다.
mvfile과 mvtest라는 폴더를 만들어서
mvfile폴더안에 abc라는 파일을 만든후
mv명령어를 사용해서 mvtest로 cba라는 이름으로 옮겨주자

넵 괜차나여 잠시만여 할머니 넹 넵 선생님 리눅스 마스터 같은 경우는 시험문제가 어떻게나와여?

넵 알겠습니다. ㅇㅋㅇㅋ 넵넹
김한서님이 모두에게:  07:58 PM
ls -l *
ls -l 1* 1로 시작하는 모든것 
ls -l *2 끝이2인 모든것
*는 공백도 받는다 *????이면 *는 1나로 치고 ????는 4개만 받으니 4개이상을 출력한다

? : 모든 문자(문자의 개수가 일치해야함)
ls -l ?	 한글자인 문자만 나옴 
ls -l ???  	 3개인 문자
ls -l *2?	 뒤에서 2번째글짜가 2	모든것 2 문자열하나 = *2?

rm ?b* 이면 두번째글자가 b인 모든것을 삭제함

rm -rf *이면 모든것 삭제


cat 이름 해당문서에 대해 보여줌

head 맨위에서 10번째줄까지만 출력해줌

tail 뒤에서부터 10번째줄 까지만 출력

tail -10 note | cat -n

tail -16 note 숫자만큼만 보여줌

tail -16을 cat -n으로 표현하겠다.

파이프 앞에있는 명령어를 파이프 뒤쪽에 있는 명령어 형식으로 표현하겠다.
-n 행번호 

find [범위] -name [이름]
네

find / -name test -o -name root 

-o or 

-type d : 디렉터리찾는다

-type f : 폴더찾는다.

vi 명령어 : vim이라는 문서편집기 리눅스의 메모장 역할  visual iditor (vi 이름)
해당 이름에 해당하는 파일이 존재하면 그 파일을 열어주고 없다면 그 이름을 가진 새로운 파일을 생성하고
열어준다.

명령모드 : 어떤걸쳐도 입력 x 콜론명령어
 :q 명령모드에서 나가는 것
 :wq 저장하고 나가기
:q! 강제종료 무시하고 나가기
안되여
:set nu 행번호 출력

w : 그다음 단어의 맨처음으로감 (문자도 단어로침 문자가 하나면 단어 연결된문자가 여러개이면 하나의 단어로침)(west)
/etc:0:x:/mind 에서 x:에서 w를누르면 m으로감
e : 단어의 끝으로감 
(east)
b : 이전단어의 처음글자로
(back)
x : 커서의위치의 글자를 하나씩 삭제한다 커서오른쪽에 더이상 글자가남지않으면 커서가 왼쪽으로이동한다

i 입력모드로 들어감

G는 문서의 제일 마지막으로 들어감 

gg 문서의 제일 앞으로 들어감

w : 그다음 단어의 맨처음으로감 (문자도 단어로침 문자가 하나면 단어 연결된문자가 여러개이면 하나의 단어로침)(west)
/etc:0:x:/mind 에서 x:에서 w를누르면 m으로감
e : 단어의 끝으로감 
(east)
b : 이전단어의 처음글자로
(back)
x : 커서의위치의 글자를 하나씩 삭제한다 커서오른쪽에 더이상 글자가남지않으면 커서가 왼쪽으로이동한다
a : 커서의 오른쪽으로 써짐 (커서의 위치는 상관없음)

i : 커서의 왼쪽에 써짐 

o : 커서의아래에 행생성후 그행의 첫번째로 커서가간다 

s : 커서자리의 글자를 삭제하고 그자리에부터 써진다

shift + o = 커서의 위쪽에 행생성후 써짐

dd는 행을 삭제한다 숫자를 먼저 누르고 dd하면 그 숫자만큼 삭제한다.

yy는 ctrl c 행을복사 (숫자 지정하고하면 숫자만큼 행을복사)

p는 ctrl v 행을 붙여 넣는다. 

0버튼은 행의 가장 처음으로 커서를 이동시켜준다.

$버튼은 행의 가장 끝으로 커서를 이동시켜준다.

d $ 커서부터 오른쪽에 있는 모든 문자 삭제

d 0 커서부터 왼쪽에 있는 모든 문자 삭제

u 되돌리기 ctrl + z

ctrl r 역으로 되돌림

다른이름으로저장 명령어 모드에서 :w 하고그이름으로 원하는 이름적어준다.

touch 명령어 사용할때 -t 같은경우는 시간을 지정가능

-r 한번에 여러개를 복사 이 경우 이름은 못바꿈

alias 단축키 지정 alias b='mkdir 12'

unalias 단축키 지정한걸 해제시킨다. unalias b

1. ROM - BIOS
ROM (Read ONly Memory)
BIOS (Basic Input OUtput System)
(1).POST (Power On Self Test)
-전원이 켜짐과 동시에 ROM에 저장되어 있던 ROM - BIOS가 실행이 되고 실행된 BIOS는 스스로 시스템에 장착된 하드웨어 장치들을 하나씩 인식, 이상유무를 체크한다. 이상이 없다면 장치의 사용을 위해 모든 장치를 초기화한다.
(이상발생시 에러음내고 멈춤)
(2).부트로더 로딩 기능
-ROM - BIOS는 Boot Loader를 가진 하드장치를 하나씩 검사한다. 그리고 가장 먼저 검색된 하드장치에서 부트로더를 불러들인다. 이렇게 부트로더를 메모리에 로딩한 이후에는 부트로더에게 제어권을 넘겨주고 자신은 종료한다.

2.부트로더 (GRUB)
(1) 리눅스 커널 로딩
-GRUB는 /boot/grub/grub.conf 파일에 저장되어 있는 리눅스 커널을 메모리로 로딩한다.

(2) Swapper 프로세스 호출

3.Swapper 프로세스
-GRUB에 의해 실행된 swapper는 PID(프로세스아이디) 0번을 가지며 각 장치 드라이버를 초기화하고 PID 1번인 init 프로세스를 실행한후 스스로 종료한다.

4.init프로세스
-swapper에 의해 실행된 init프로세스는 /etc/inittab 이라는 설정파일을 읽어 들여 무엇을, 언제, 어떻게 실행할 것인지 결정한다.
-가장 먼저 시스템 부팅레벨이 결정되고 /etc/init/rcS.conf가 실행된 뒤 /etc/init/rc.conf가 실행된다

/etc/init/rcS.conf -> rc.sysinit 스크립트실행 -> /etc/init/rc.conf -> etc/rc.d/rc[0-6].d

5.rc.sysinit스크립트 실행 (스크립트 : 간단한 언어로 작성한 명령어)
- '시스템 초기화' 작업을 수행하는 스크립트이다. 부팅과정에서 보는 거의 모든내용들이 이 파일에 의한 수행내용이다.

6./etc/rc.d/rc[0-6].d 안의 스크립트 실행
-inittab에 지정된 런레벨에 따라 /etc/rc.d/rc[런 레벨].d의 디렉토리의 스크립트 파일이 순차적으로 실행된다.
S로 시작하는 파일이 부팅시 자동시작되고 K로 시작하는 파일은 시작안함. 원본은/etc/rc.d/init.d/ 디렉토리에 존재한다.

7./etc/rc.d/rc/local 실행
-런레벨 2,3,4,5,번에서 맨 마지막 단게에 실행된다. 부팅시에 자동으로 실행하고자하는 프로그램들을 설정해놓는 곳이다.

8./sbin/mingetty 실행
/sbin/mingetty 는 init 프로세스에 의해 실행되며 대기하고 있다가 사용자가  ID를 입력하면 login프로세스를 실행시킨다.

9.로그인을 완료후
/etc/profile 을 실행하여 사용자 환경을 설정한다.
로그인한 사용자의 홈디렉토리의 ./profile을 실행한다.
사용자의 지정된 쉘에 대한 .[쉘명]rc파일을 구동한다
/etc/[쉘명]rc파일을 구동한다

0 - halt         init 0(종료)

1 - Single user mode    텍스트부팅

2 - Multyuser, without NFS     NFS = 공유폴더,네트워크사용안하는모드

3 - Full multyuser mode   네트워크 사용가능

4 - unused   사용자 정의레벨   사용자가 설정해놓은 방법으로 부팅

5 - X11   X = GUI      그래픽모드 부팅

6 - reboot      재시작 init6

shell의 종류

하드웨어를 실행시킬려면 커널(OS)가 필요하고 OS를 컨트롤하기위해서는 Shell이 필요하다 User는 Shell을 사용하여 kernel을
컨트롤한다

sh(본쉘) : 리눅스의 기본 쉘, 응급 복구 쉘

ksh (콘쉘) : k는 console이아니라 David kon이만듬 터미널에서 사용하고있는쉘임 유닉스 기본쉘

dash : 우분투 기본쉘 (debian리눅스 계열)

csh : c언어 쉘

tcsh : csh확장쉘

bash : 범용 리눅스 응용 쉘 (sh, ksh, csh 3개의 장점을 합친 복합쉘)

no login : 시스템쉘

user   일반유저   


group   권한을 한번에 주기위한 user모임

-useradd      추가
-usermod   수정
-userdel      삭제
-groupadd   그룹추가
-groupmod   수정
-groupdel   삭제

/etc/passwd      계정정보파일   (비밀번호 파일이아니다)

/etc/group      그룹정보파일

/etc/shadow      패스워드 정보파일

/home/계정명      계정 홈 디렉토리

/var/spool/mail/계정명   계정 메일함

계정을 하나 생성시 위의 5개가 생성된다

그룹은 /etc/group만 적용댐

/etc/default/useradd   계정생성(useradd)시 기본값이 저장된곳

bash 현재 사용하고있는 리눅스에 shell을 파악하기 위해 좋은방법 아무 명령어나 친다 치면 어떤 쉘을 사용하고있는지 나타난다.

/etc/login.defs 가 유저 설정 파일

vi명령모드에서 콜론 숫자를 치면 그 숫자의 행의 위치로 커서가 이동한다.

login.defs  
15번 째 줄보시면 MAIL_DIR 오른쪽에 써져있는 경로가 메일이 생성되는 경로 

#: 주석

25번째 줄에 있는 PASS_MAX_DAYS는 오른쪽에 있는 숫자만큼 비밀번호 변경주기이다.
PASS_MIN_DAYS 최소 사용일수 
PASS_MIN_LEN 비밀번호의 최소 길이
PASS_WARN_AGE 비밀번호 만료일 최대사용일수의 -숫자의 날짜일때 경고를 해준다.

UID_MIN 유저아이디의 최소값
UID_MAX 는 유저아이디의 최대값

GID_MIN  그룹 아이디의 최소값
GID_MAX 그룹 아이디의 최대값

CREATE_HOME 부분은 오른 쪽에있는 문자가 YES냐 NO에따라 계정생성시 홈디렉터리의 생성의 여부를 확인한다.

UMASK 홈디렉터리 기본권한

USERGRUPS_ENAB 가 계정 삭제시 소속그룹이 비어있으면 그룹도 같이 삭제하겠는가?에 대해서 물어보는 것

ENCRYPT_METHOD 오른쪽에 SHA512는 해싱알고리즘 선택방법

------------------------
/etc/passwd 설명 생성된 계정들에 대한 정보가 저장되어있다.

계정명:의미없음:UID:GID:계정설명(아무것도 안넣을수도있음):홈디렉토리위치:사용쉘

: = 구분자


---------------------------

vi /etc/default/useradd

유저를 만들때 기본옵션

GROUP=100      계정생성시그룹지정(100 = 계정명과 동일한 그룹명 or UID와 동일한 GID로 그룹생성)
HOME=/home      홈디렉토리 생성 위치 (/home 안에 생성하겠다)
INACTIVE=-1      pw 만료시에 처리를 어떻게 할것이냐 -1 = 미지정   /etc/shadow형식을 다시한번보자
EXPIRE=         pw만료일
SHELL=/bin/bash      무슨쉘사용하는지 (수정하면 수정하는대로 써짐)
SKEL=/etc/skel      홈디렉토리에 뼈대 경로를 지정할떄 여기서 지정      후에배움
CREATE_MAIL_SPOOL=yes   메일함을 생성할것이냐 y/n   경로는  login.defs에있음

groupadd 그룹 만들기
groupmod 그룹 수정
groupdel 그룹삭제

사용자를 생성할때는 홈 디렉터리안에 폴더가 생성 되지만 그룹은 최상위 /etc/group 파일안에 생성된다. 

UID와 GID는 각각 유저와 그룹에 부여되는 식별번호이다. UID와 GID에서 특정 범위와 특정 번호는 시스템에서 기본적으로 주어진게 존재하기 때문에 일정 번호 이상의 값들만 사용가능하다.



groupadd에서-g 옵션은 GID값을 설정하게 해준다. 

gid값이 존재하면 해당 그룹과 같은 gid는 만들지 못한다. 그리고 vi편집기에서 커서가있는 줄을 삭제하기위해서는
dd명령어를 사용한다. 

/etc/group파일은 텍스트 파일이기 때문에 명령어가 아니더라도 수정을 통해서 그룹의 이름과 GID값을 바꿀수있고 삭제도 가능하다.